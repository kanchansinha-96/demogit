// vars/teamsNotification.groovy
def call(Map config = [:]) {
    def status = config.status ?: currentBuild.currentResult
    def customMessage = config.message ?: ''
    
    // Check if triggered by service account
    if (isTriggeredByServiceAccount()) {
        echo "Build triggered by service account (svc). Skipping Teams notification."
        return
    }
    
    // Get folder name from job path
    def folderName = getFolderName()
    echo "Detected folder name: ${folderName}"
    
    // Load webhook URL from properties file
    def webhookUrl = getWebhookUrlForFolder(folderName)
    
    if (!webhookUrl) {
        error "No Teams webhook URL found for folder: ${folderName}"
    }
    
    def color = getColorByStatus(status)
    def statusEmoji = getEmojiByStatus(status)
    def buildUrl = env.BUILD_URL ?: 'N/A'
    def jobName = env.JOB_NAME ?: 'Unknown Job'
    def buildNumber = env.BUILD_NUMBER ?: 'N/A'
    def triggeredByInfo = getTriggeredByDetails()
    
    // Build facts array with only required fields
    def facts = [
        [
            "name": "Pipeline URL:",
            "value": buildUrl
        ],
        [
            "name": "Status:",
            "value": status
        ]
    ]
    
    // Add triggered by user name
    if (triggeredByInfo.userName) {
        facts << [
            "name": "Triggered By:",
            "value": triggeredByInfo.userName
        ]
    }
    
    // Add user email if available
    if (triggeredByInfo.userEmail) {
        facts << [
            "name": "Triggered By Email:",
            "value": triggeredByInfo.userEmail
        ]
    }
    
    // Add failed stage if build failed
    if (status == 'FAILURE' || status == 'UNSTABLE') {
        def failedStage = getFailedStage()
        if (failedStage) {
            facts << [
                "name": "Failed Stage:",
                "value": failedStage
            ]
        }
    }
    
    def payload = [
        "@type": "MessageCard",
        "@context": "https://schema.org/extensions",
        "summary": "Jenkins Build Notification",
        "themeColor": color,
        "title": "${statusEmoji} Jenkins Build ${status}",
        "sections": [
            [
                "activityTitle": "**${jobName}**",
                "activitySubtitle": "Build #${buildNumber}",
                "facts": facts,
                "text": customMessage
            ]
        ],
        "potentialAction": [
            [
                "@type": "OpenUri",
                "name": "View Build",
                "targets": [
                    [
                        "os": "default",
                        "uri": buildUrl
                    ]
                ]
            ]
        ]
    ]
    
    // Write JSON payload to temporary file
    def jsonPayload = groovy.json.JsonOutput.toJson(payload)
    
    // Pretty print JSON for better readability in logs
    def prettyJson = groovy.json.JsonOutput.prettyPrint(jsonPayload)
    
    def tempFile = "${env.WORKSPACE}/teams-payload-${env.BUILD_NUMBER}.json"
    
    writeFile file: tempFile, text: jsonPayload, encoding: 'UTF-8'
    
    echo "JSON payload created:"
    echo prettyJson
    
    // Verify file was created
    def fileExists = fileExists(tempFile)
    if (!fileExists) {
        error "Failed to create JSON payload file: ${tempFile}"
    }
    
    echo "JSON file created successfully: ${tempFile}"
    
    // Send notification using curl
    sendTeamsNotification(webhookUrl, tempFile)
    
    // Clean up temp file
    sh "rm -f ${tempFile}"
}

def getFolderName() {
    try {
        def jobUrl = env.JOB_URL
        
        if (!jobUrl) {
            echo "JOB_URL not available, falling back to JOB_NAME parsing"
            def jobName = env.JOB_NAME
            if (jobName.contains('/')) {
                def parts = jobName.split('/')
                return parts[0]
            }
            return 'default'
        }
        
        // Parse URL to extract 7th word after slash
        // Example: https://jenkins.example.com/job/folder1/job/folder2/job/jobname/
        // Split by '/' and get the 7th element (index 6)
        def urlParts = jobUrl.split('/')
        
        echo "Job URL: ${jobUrl}"
        echo "URL parts count: ${urlParts.size()}"
        
        // The 7th word after slash would be at index 6 (0-based)
        if (urlParts.size() > 6) {
            def folderName = urlParts[6]
            echo "Extracted folder name from URL position 7: ${folderName}"
            return folderName
        } else {
            echo "URL doesn't have enough parts, using default"
            return 'default'
        }
    } catch (Exception e) {
        echo "Error extracting folder name: ${e.message}"
        return 'default'
    }
}

def getWebhookUrlForFolder(folderName) {
    try {
        // Load properties file from resources
        def propsContent = libraryResource 'teams-webhooks.properties'
        def props = new Properties()
        props.load(new StringReader(propsContent))
        
        // Try to get folder-specific URL
        def webhookUrl = props.getProperty("teams.webhook.${folderName}")
        
        // Fallback to default if folder-specific not found
        if (!webhookUrl) {
            echo "No specific webhook found for folder '${folderName}', using default"
            webhookUrl = props.getProperty('teams.webhook.default')
        }
        
        return webhookUrl
    } catch (Exception e) {
        error "Failed to load Teams webhook configuration: ${e.message}"
    }
}

def sendTeamsNotification(webhookUrl, jsonFile) {
    try {
        // Validate JSON file exists and is valid
        def jsonContent = readFile(jsonFile)
        
        // Validate it's proper JSON
        try {
            def parsedJson = new groovy.json.JsonSlurper().parseText(jsonContent)
            echo "JSON payload validated successfully"
        } catch (Exception e) {
            error "Invalid JSON format: ${e.message}"
        }
        
        def curlCommand = """
            curl -X POST '${webhookUrl}' \\
            -H 'Content-Type: application/json; charset=UTF-8' \\
            -H 'Accept: application/json' \\
            --data-binary @${jsonFile} \\
            --silent \\
            --show-error \\
            --write-out '\\nHTTP_STATUS:%{http_code}' \\
            --fail-with-body
        """
        
        def output = sh(script: curlCommand, returnStdout: true).trim()
        
        // Parse HTTP status from output
        def statusMatch = output =~ /HTTP_STATUS:(\d+)/
        if (statusMatch) {
            def httpStatus = statusMatch[0][1]
            echo "Teams notification sent successfully. HTTP Status: ${httpStatus}"
            
            if (httpStatus != '200') {
                echo "Warning: Received non-200 status. Response: ${output}"
            }
        } else {
            echo "Teams notification sent. Response: ${output}"
        }
        
    } catch (Exception e) {
        echo "Error sending Teams notification: ${e.message}"
        echo "Please verify:"
        echo "  1. Webhook URL is correct"
        echo "  2. Teams connector is active"
        echo "  3. JSON payload format is valid"
    }
}

def getColorByStatus(status) {
    def colors = [
        'SUCCESS': '00FF00',
        'FAILURE': 'FF0000',
        'UNSTABLE': 'FFA500',
        'ABORTED': '808080',
        'NOT_BUILT': '808080'
    ]
    return colors[status] ?: '0078D7'
}

def getEmojiByStatus(status) {
    def emojis = [
        'SUCCESS': '‚úÖ',
        'FAILURE': '‚ùå',
        'UNSTABLE': '‚ö†Ô∏è',
        'ABORTED': 'üõë',
        'NOT_BUILT': '‚è∏Ô∏è'
    ]
    return emojis[status] ?: '‚ÑπÔ∏è'
}

def getTriggeredByDetails() {
    def result = [
        userName: null,
        userEmail: null
    ]
    
    try {
        def causes = currentBuild.getBuildCauses()
        if (causes) {
            def cause = causes[0]
            
            if (cause._class.contains('UserIdCause')) {
                // Get user name
                result.userName = cause.userName ?: cause.userId ?: 'Manual Trigger'
                
                // Try to get user email
                if (cause.userId) {
                    try {
                        def user = hudson.model.User.get(cause.userId, false)
                        if (user) {
                            def emailProperty = user.getProperty(hudson.tasks.Mailer.UserProperty.class)
                            if (emailProperty) {
                                result.userEmail = emailProperty.getAddress()
                            }
                        }
                    } catch (Exception e) {
                        echo "Could not retrieve user email: ${e.message}"
                    }
                }
            } else if (cause._class.contains('SCMTrigger')) {
                result.userName = 'SCM Change'
            } else if (cause._class.contains('TimerTrigger')) {
                result.userName = 'Scheduled'
            } else if (cause._class.contains('UpstreamCause')) {
                result.userName = "Upstream: ${cause.upstreamProject}"
            } else {
                result.userName = 'Unknown'
            }
        } else {
            result.userName = 'Unknown'
        }
    } catch (Exception e) {
        echo "Error getting triggered by details: ${e.message}"
        result.userName = 'Unknown'
    }
    
    return result
}

def isTriggeredByServiceAccount() {
    try {
        def causes = currentBuild.getBuildCauses()
        if (causes) {
            for (cause in causes) {
                // Check if triggered by a user
                if (cause._class.contains('UserIdCause')) {
                    def userId = cause.userId ?: ''
                    def userName = cause.userName ?: ''
                    
                    echo "Triggered by user: ${userId} (${userName})"
                    
                    // Check if user ID or name contains 'svc' (case-insensitive)
                    if (userId.toLowerCase().contains('svc') || userName.toLowerCase().contains('svc')) {
                        echo "Service account detected: ${userId}"
                        return true
                    }
                }
            }
        }
        
        // Also check BUILD_USER_ID environment variable if available
        if (env.BUILD_USER_ID && env.BUILD_USER_ID.toLowerCase().contains('svc')) {
            echo "Service account detected from BUILD_USER_ID: ${env.BUILD_USER_ID}"
            return true
        }
        
    } catch (Exception e) {
        echo "Error checking for service account: ${e.message}"
    }
    
    return false
}

def getFailedStage() {
    try {
        // Get the execution details of the current build
        def build = currentBuild.rawBuild
        def execution = build.getExecution()
        
        if (execution) {
            // Get all nodes (stages) in the pipeline
            def nodes = execution.getCurrentHeads()
            
            // Look for failed stages
            for (node in nodes) {
                if (node.getError() != null) {
                    def stageName = node.getDisplayName()
                    echo "Found failed stage: ${stageName}"
                    return stageName
                }
            }
            
            // Alternative method: Check through all nodes
            def allNodes = execution.getNodes()
            for (node in allNodes) {
                if (node.getError() != null) {
                    def stageName = node.getDisplayName()
                    echo "Found failed stage: ${stageName}"
                    return stageName
                }
            }
        }
        
        // Fallback: Try to extract from build log
        def log = currentBuild.rawBuild.getLog(100)
        for (line in log) {
            // Look for stage failure patterns
            if (line =~ /(?i)stage.*failed/ || line =~ /(?i)failed.*stage/) {
                def matcher = line =~ /\[([^\]]+)\]/
                if (matcher) {
                    return matcher[0][1]
                }
            }
        }
        
    } catch (Exception e) {
        echo "Could not retrieve failed stage: ${e.message}"
    }
    
    return "Unknown Stage"
}
